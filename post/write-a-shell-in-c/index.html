<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>[译］教程 - 用C实现一个Shell - Zvector &amp; Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
  
  <meta name="description" content="原文链接：Tutorial - Write a Shell in C，作者：Stepthen Brennan 16 January 2015 我们很容易自视为”不是一个真正的程序员“。存在那些人尽皆知的程序，使得">
  <meta name="author" content="zvector">
  <meta itemprop="name" content="[译］教程 - 用C实现一个Shell - Zvector &amp; Blog">
  <meta itemprop="description" content="原文链接：Tutorial - Write a Shell in C，作者：Stepthen Brennan 16 January 2015 我们很容易自视为”不是一个真正的程序员“。存在那些人尽皆知的程序，使得">
  <meta itemprop="image" content="https://bivectorfoil.github.io/img/author.jpg">
  
  
  <meta name="twitter:description" content="">
  
  <link rel="shortcut icon" href="https://bivectorfoil.github.io/img/favicon.ico"/>
  <link rel="apple-touch-icon" href="https://bivectorfoil.github.io/apple-touch-icon.png" />
  <link rel="apple-touch-icon-precomposed" href="https://bivectorfoil.github.io/apple-touch-icon.png" />
  <link rel="stylesheet" href="https://bivectorfoil.github.io/highlight/styles/github.css">
  <script src="https://bivectorfoil.github.io/highlight/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <link rel="stylesheet" href="https://bivectorfoil.github.io/font/hack/css/hack.min.css">
  <link rel="stylesheet" href="https://bivectorfoil.github.io/css/style.css">
</head>

<body>
  <header>
    <div>
  
  <div id="imglogo">
    <a href="https://bivectorfoil.github.io/"><img src="https://bivectorfoil.github.io/img/logo.svg" alt="Zvector &amp; Blog" title="Zvector &amp; Blog"/></a>
  </div>
  
  <div id="textlogo">
    <h1 class="site-name"><a href="https://bivectorfoil.github.io/" title="Zvector &amp; Blog">Zvector &amp; Blog</a></h1>
    <h2 class="blog-motto">Connect the world</h2>
  </div>
  <div class="navbar"><a class="navbutton navmobile" href="#" title="menu"></a></div>
  <nav class="animated">
    <ul>
      
      <li><a href="/">首页</a></li>
      
      <li><a href="/about">关于</a></li>
      
      <li>
        <form class="search" method="get" action="https://www.google.com/search">
          <div>
            <input type="text" id="search" name="q" placeholder="搜索">
          </div>
        </form>
      </li>
    </ul>
  </nav>
</div>

  </header>
  <div id="container">
    <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody">
    <header class="article-info clearfix">
  <h1 itemprop="name">
      <a href="https://bivectorfoil.github.io/post/write-a-shell-in-c/" title="[译］教程 - 用C实现一个Shell" itemprop="url">[译］教程 - 用C实现一个Shell</a>
  </h1>
  <p class="article-author">By
    
      <a href="https://bivectorfoil.github.io/" title="zvector">zvector</a>
    
  </p>
  <p class="article-time">
    <time datetime="2018-03-31 21:52:55 &#43;0800 CST" itemprop="datePublished">2018年03月31日</time>
  </p>
</header>

	<div class="article-content">
    
		<div class="toc-article">
			<strong class="toc-title">文章目录</strong>
      <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#shell的基本生命周期">Shell的基本生命周期</a></li>
<li><a href="#shell的基本循环">Shell的基本循环</a></li>
<li><a href="#读取输入">读取输入</a></li>
<li><a href="#解析输入">解析输入</a></li>
<li><a href="#shell如何启动进程">Shell如何启动进程</a></li>
<li><a href="#shell内置函数">Shell内置函数</a></li>
<li><a href="#将内置函数和进程整合起来">将内置函数和进程整合起来</a></li>
<li><a href="#组织代码">组织代码</a></li>
<li><a href="#总结">总结</a></li>
</ul></li>
</ul>
</nav>
		</div>
    
    

<blockquote>
<p>原文链接：<a href="https://brennan.io/2015/01/16/write-a-shell-in-c/">Tutorial - Write a Shell in C</a>，作者：<a href="https://brennan.io/">Stepthen Brennan</a> 16 January 2015</p>
</blockquote>

<p>我们很容易自视为”不是一个真正的程序员“。存在那些人尽皆知的程序，使得其中相关的研发者很容易地被推上神坛。尽管研发大型软件项目并不容易，但很多时候这些软件的基本思想是十分简单的。亲自去实现是学习如何成为一个真正的程序员的有趣方法。本文就是关于我如何用C实现简易的Unix Shell的演练，希望其他人也能从中体会到同样的乐趣。</p>

<p>本文所描述的Shell名为：lsh, 可以在<a href="https://github.com/brenns10/lsh">Github</a>上找到它。</p>

<p><strong>大学生注意告示！</strong>很多课程会要求你们实现一个Shell，一些教师也知道本文及其代码。如果你是这些课程的其中一员，你不应未经允许地复制这些代码（或复制后修改）。即使如此，我强烈建议不要过度依赖本教程。（关于本段，参考作者的另一篇<a href="https://brennan.io/2016/03/29/dishonesty/">博文</a>，译者注）</p>

<h2 id="shell的基本生命周期">Shell的基本生命周期</h2>

<p>让我们宏观地了解下Shell。一个Shell在它的生命周期中主要做三件事情。</p>

<ul>
<li>初始化：在这一步，Shell会读取并执行自身的配置文件。这些配置文件改变了Shell的操作特性。</li>
<li>解释：接下来，Shell从标准输入读取命令（可以是交互命令，或文件）并执行之。</li>
<li>终止：在其命令执行后，Shell执行任意关机命令，释放内存并终止。</li>
</ul>

<p>上述流程是如此普遍以至于可以应用到很多程序中去，我们将在自己的Shell中实现这些流程。我们的Shell是十分简单的，以至于它不需要任何的配置文件，也不会有任何的关机命令。所以，我们只需要调用循环函数然后终止就好。但在架构方面，需要时刻注意程序的生命周期远不止循环。</p>

<pre><code class="language-c">int main(int argc, char **argv)
{
  // Load config files, if any.
  
  // Run command loop.
  lsh_loop();
  
  // Perform any shutdown/cleanup.
  
  return EXIT_SUCCESS;
}
</code></pre>

<p>在这你可以看到我刚刚用到的函数，<code>lsh_loop()</code>，将会开始循环，解释命令。接下来我们将看到其具体实现。</p>

<h2 id="shell的基本循环">Shell的基本循环</h2>

<p>我们已经知道到程序应该如何启动了。现在，就程序基本逻辑来说：shell在循环中该怎么做？简单来说，处理命令有三个步骤：</p>

<ul>
<li>读取：从标准输入中读取命令。</li>
<li>解析：将命令字符串分隔为程序名和参数。</li>
<li>执行：运行解析后的命令。</li>
</ul>

<p>将上述步骤写成<code>lsh_loop()</code>代码:</p>

<pre><code class="language-c">void lsh_loop(void)
{
  char *line;
  char **args;
  int status;
  
  do {
    printf(&quot;&gt; &quot;);
    line = lsh_read_line();
    args = lsh_split_line(line);
    status = lsh_execute(args);
    
    free(line);
    free(args);
  } while (status);
}
</code></pre>

<p>让我们过一遍代码。前几行是声明。do-while循环更适合用于检查<code>status</code>，因为它在检查前会执行一次命令。在本循环中，我们打印一个命令提示符，调用函数读取输入，调用函数将输入分割进<code>args</code>， 并执行<code>args</code>。最后释放原先创建的参数空间。注意，我们使用由<code>lsh_execute()</code>返回的变量<code>status</code>来决定何时退出程序。</p>

<h2 id="读取输入">读取输入</h2>

<p>读取标准输入听上去似乎很简单，但在C中有点麻烦。棘手的是，你无法提前知道用户会在Shell中输入多少内容。你不能只是简单地分配一块空间，然后希望用户不要超量使用它。因此，你需要从一块空间开始，一旦用户使用量超过了它，立马重新分配更多的空间。这在C中是一个常用策略，我们依据这个想法来实现<code>lsh_read_line()</code>。</p>

<pre><code class="language-c">#define LSH_RL_BUFSIZE 1024
char *lsh_read_line(void)
{
  int bufsize = LSH_RL_BUFSIZE;
  int position = 0;
  char *buffer = malloc(sizeof(char) * bufsize);
  int c;

  if (!buffer) {
    fprintf(stderr, &quot;lsh: allocation error\n&quot;);
    exit(EXIT_FAILURE);
  }

  while (1) {
    // Read a character
    c = getchar();

    // If we hit EOF, replace it with a null character and return.
    if (c == EOF || c == '\n') {
      buffer[position] = '\0';
      return buffer;
    } else {
      buffer[position] = c;
    }
    position++;

    // If we have exceeded the buffer, reallocate.
    if (position &gt;= bufsize) {
      bufsize += LSH_RL_BUFSIZE;
      buffer = realloc(buffer, bufsize);
      if (!buffer) {
        fprintf(stderr, &quot;lsh: allocation error\n&quot;);
        exit(EXIT_FAILURE);
      }
    }
  }
  
}
</code></pre>

<p>第一部分是一堆声明。如果你没注意到的话，我建议在接下来的代码中保留旧版C标准风格声明变量的方式。函数主体是一个（无限循环的）<code>while(1)</code>循环。在循环中，我们每次读取一个字符（并将其存储为<code>int</code>，而不是<code>char</code>， 这非常重要！EOF是整数型，而不是字符型，如果你想要将读取的字符与EOF做对比检查，你应该使用<code>int</code>。这是C新手常犯的一个错误。）。如果它是换行符，或EOF，我们终止当前字符串并返回它。不然，就将其添加到已存在的字符串中。</p>

<p>接下来，我们检查下一个输入字符是否超出了当前的缓冲区。如果是，我们在继续之前重新分配缓冲区（检查分配错误）。整个流程就是如此了。</p>

<p>对熟悉新版C标准库的人来说，可能会注意到在<code>stdio.h</code>头文件中有一个函数<code>getline()</code>，它可以提供大部分我们才刚刚实现的功能。坦诚来说，我在完成这份代码之前并不知道有这个函数的存在。这个GUN拓展函数在2008年时被添加到C标准库规范之中，所以大多数的现代Unix系统应该都已配备了。我将保留原来的代码实现，并且鼓励你们应首先学习这样的实现而不是一开始就使用<code>getline</code>。若不如此的话，你就是剥夺了自己一次学习的机会了。不管怎样，使用<code>getline</code>的话，<code>lsh_read_line()</code>函数可改写为如下：</p>

<pre><code class="language-c">char *lsh_read_line(void)
{
  char *line = NULL;
  ssize_t bufsize = 0; // have getline allocate a buffer for us
  getline(&amp;line, &amp;bufsize, stdin);
  return line;
}
</code></pre>

<h2 id="解析输入">解析输入</h2>

<p>好了，如果我们回顾一下loop循环，可以看到我们已经实现了<code>lsh_read_line()</code>，也有了输入流。现在，我们需要将输入解析为参数列表。在这里我要做一个简化，在我们的命令行参数中并不支持引号或反斜杠。作为替代，我们使用空格来作为参数间的分割符。所以形如命令 ：<code>echo &quot;this message&quot;</code>并不会直接将参数<code>this message</code>给传递到<code>echo</code>中，而是分为两个参数：<code>&quot;this&quot;</code>和<code>&quot;message&quot;</code>。</p>

<p>在这样的简化下，我们所需要做的就是使用空格作为分隔符来”解析标记“输入字符串。如此一来我们就可以利用库函数<code>strtok</code>来完成一些繁杂的工作。</p>

<pre><code class="language-c">#define LSH_TOK_BUFSIZE 64
#define LSH_TOK_DELIM &quot; \t\r\n\a&quot;
char **lsh_split_line(char *line)
{
  int bufsize = LSH_TOK_BUFSIZE, position = 0;
  char **tokens = malloc(bufsize * sizeof(char*));
  char *token;

  if (!tokens) {
    fprintf(stderr, &quot;lsh: allocation error\n&quot;);
    exit(EXIT_FAILURE);
  }

  token = strtok(line, LSH_TOK_DELIM);
  while (token != NULL) {
    tokens[position] = token;
    position++;

    if (position &gt;= bufsize) {
      bufsize += LSH_TOK_BUFSIZE;
      tokens = realloc(tokens, bufsize * sizeof(char*));
      if (!tokens) {
        fprintf(stderr, &quot;lsh: allocation error\n&quot;);
        exit(EXIT_FAILURE);
      }
    }

    token = strtok(NULL, LSH_TOK_DELIM);
  }
  tokens[position] = NULL;
  return tokens;
}
</code></pre>

<p>如果你觉得这段代码看起来和<code>lsh_read_line()</code>十分相似的话，那是因为正是如此！我们采取了同样的策略，使用并动态拓展缓冲区。但这一次，我们用一个以null结尾的指针数组来代替以null结尾的字符数组。</p>

<p>在函数开头，我们调用<code>strtok</code>来进行解析<code>token</code>。它返回一个指向第一个<code>token</code>的指针。<code>strtok()</code>实际上做的是返回指向你提供给它的字符串的指针，并在每一个<code>token</code>的后面添加<code>\0</code>字符。我们将每个指针存储在字符指针数组（缓冲区）中。</p>

<p>最后，如果有必要的话，我们重新分配指针数组。这个过程反复进行直到<code>strtok</code>函数不再返回<code>token</code>，此时我们终止<code>tokens</code>列表。</p>

<p>好了，一旦准备周全后，我们有了一个<code>tokens</code>数组，准备开始执行了。那么问题来了，我们应该怎么做？</p>

<h2 id="shell如何启动进程">Shell如何启动进程</h2>

<p>目前，我们开始深入到了Shell工作原理的核心。开启进程是Shell的主要功能。所以编写一个Shell意味着你必须清楚地知道进程中发生了什么，以及它们是如何启动的。正因此，我要稍稍岔开话题，单独地来谈谈Unix中的进程。</p>

<p>在Unix中启动进程只有两种方法。第一种（基本可以不考虑）是通过初始化。可以想见，当Unix系统启动时，它的内核开始加载。一旦其加载和初始化完成，内核只会开始运行一个进程，即为<code>Init</code>进程。此进程在系统的整个生命周期一直运行，它管理加载你计算机所需要的其他进程。</p>

<p>既然大多数程序不会是<code>Init</code>进程，对进程启动来说就只剩下唯一一个实际的途径：<code>fork()</code>系统调用。当此函数被调用时，操作系统会复制进程并保持它们同时运行。原先的进程被称为”父进程“，复制出的新进程被称为”子进程“。<code>fork()</code>向子进程返回0，向父进程返回子进程的进程ID（PID）。本质上来说，开启新进程的唯一方法就是从已有的进程上复制一份。</p>

<p>这听起来似乎有个问题。技术上来说，当你想要启动一个新进程时，你并不是想要一个当前程序的复制品——你想要运行另一个程序。这就是<code>exec()</code>系统调用所要做的事情。（为方便理解，此句与原文有出入，出自<a href="https://zh.wikipedia.org/wiki/Fork_(%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8)">Wikipedia</a>——译者注）用其他程序覆盖自身：停止执行自己之前的程序并执行其他程序。这就意味着当你调用<code>exec()</code>后， 操作系统停止你的进程，加载新的程序，并启动它。一个进程永远不会从<code>exec()</code>调用返回（除非出现了错误）。</p>

<p>通过这两个系统调用，我们大概可以知道在Unix系统上大部分程序的运行方式了。首先，一个已存在的进程调用<code>fork</code>来创建一个自身的副本。然后，子进程调用<code>exec()</code>，用一个新的程序来替代自己。父进程可以继续运行下去，甚至可以通过系统调用<code>wait()</code>，来保持对子进程的跟踪。</p>

<p>呼！了解了这么多信息，但是根据这些背景知识，也使得接下来这个启动程序的代码是顺理成章的了：</p>

<pre><code class="language-c">int lsh_launch(char **args)
{
  pid_t pid, wpid;
  int status;

  pid = fork();
  if (pid == 0) {
    // Child process
    if (execvp(args[0], args) == -1) {
      perror(&quot;lsh&quot;);
    }
    exit(EXIT_FAILURE);
  } else if (pid &lt; 0) {
    // Error forking
    perror(&quot;lsh&quot;);
  } else {
    // Parent process
    do {
      wpid = waitpid(pid, &amp;status, WUNTRACED);
    } while (!WIFEXITED(status) &amp;&amp; !WIFSIGNALED(status));
  }

  return 1;
}
</code></pre>

<p>好了，此函数接收我们先前创建出的参数列表。然后，它分支出进程，并保存返回值。一旦<code>fork()</code>函数调用返回，我们就有了*两个*同时运行的进程了。第一个即为子进程如果满足情况（<code>pid</code> == 0）的话。</p>

<p>在子进程中，我们希望运行用户提供的命令。所以，我们使用系统调用<code>exec</code>的众多变种之一，<code>execvp</code>。<code>exec</code>的不同变种提供了不同的功能，有些需要可变数量的字符串参数，有些则需要字符串列表。更有一些让你特别选定进程运行的环境。这一个（指execvp）特别的变种（第一个参数必须是程序名），需要一个程序名和一个字符串参数数组（也称为矢量，‘v&rsquo;)。’p‘意味着我们选择提供程序名，并让操作系统寻找环境路径（PATH）中的程序，而不是为了运行程序而提供完整的文件路径。</p>

<p>如果<code>execvp</code>命令返回 -1（或者它有返回状态的话），我们就知道有错误出现了。所以，我们使用<code>perror</code>来打印程序名和系统错误信息，这样用户就可以知道是哪儿出了错。然后，程序退出留待Shell继续运行。</p>

<p>第二种情况（pid &lt; 0）检查<code>fork()</code>是否出现错误。如果出现了，我们将其打印出来并继续——除了告知用户此错误并由他们来决定是否需要退出以外，我们别无他法。</p>

<p>第三种情况意味着<code>fork()</code>成功执行。父进程将保持不变。我们知道子进程将要开始执行，所以父进程需要等待命令完成运行。我们使用<code>waitped()</code>来等待进程的状态改变。棘手的是，<code>waitpid()</code>有许多选项（正如<code>exec()</code>一样）。进程可能会以多种方式改变状态，并不是所有的方式都表示进程已经结束了。一个进程可能是退出了（普通情况下，或伴随一个错误码），也可能是被信号终止。所以，我们用<code>waitpid()</code>提供的宏来等待进程退出或是终止。然后，函数最终返回1，作为调用此函数的信号，我们应该再次提示输入。</p>

<h2 id="shell内置函数">Shell内置函数</h2>

<p>你可能已经注意到了，<code>lsh_loop()</code>函数循环中调用的是<code>lsh_execute()</code>函数，而我们却以<code>lsh_launch()</code>命名我们上述实现的函数。这是有意为之的！可以看到，Shell执行的大部分命令都是（外部）程序，但不是全部。其中有一些是Shell的内置函数。</p>

<p>这样做的理由很简单。（举例来说）如何你想要改变目录，你需要使用<code>chdir()</code>函数。然而，当前所在目录是进程的一个属性。所以，如果你写了一个名为<code>cd</code>的更改目录的程序，它只会改变它自己的目录，然后便终止了。它的父进程的目录并不会改变。然而，shell进程本身需要执行chdir（），以便更新自己的当前目录。这样，当它启动子进程时，子进程也可以继承该目录了。</p>

<p>类似的，如果有一个名为<code>exit</code>的程序，它理应不会使得调用它的Shell退出。同样的，对大多数的Shell来说，是通过运行类似<code>~/.bashrc</code>的配置脚本来对自身进行配置的。这些脚本使用改变Shell操作方式的命令。要做到这一点，只有在这些命令是Shell的内部实现的前提下才有可能。</p>

<p>如此一来，添加一些Shell的内置命令也就变得顺理成章了。我为自己的Shell选择的是<code>cd</code>，<code>exit</code>，和<code>help</code>。下面是它们的函数实现：</p>

<pre><code class="language-c">/*
  Function Declarations for builtin shell commands:
 */
int lsh_cd(char **args);
int lsh_help(char **args);
int lsh_exit(char **args);

/*
  List of builtin commands, followed by their corresponding functions.
 */
char *builtin_str[] = {
  &quot;cd&quot;,
  &quot;help&quot;,
  &quot;exit&quot;
};

int (*builtin_func[]) (char **) = {
  &amp;lsh_cd,
  &amp;lsh_help,
  &amp;lsh_exit
};

int lsh_num_builtins() {
  return sizeof(builtin_str) / sizeof(char *);
}

/*
  Builtin function implementations.
*/
int lsh_cd(char **args)
{
  if (args[1] == NULL) {
    fprintf(stderr, &quot;lsh: expected argument to \&quot;cd\&quot;\n&quot;);
  } else {
    if (chdir(args[1]) != 0) {
      perror(&quot;lsh&quot;);
    }
  }
  return 1;
}

int lsh_help(char **args)
{
  int i;
  printf(&quot;Stephen Brennan's LSH\n&quot;);
  printf(&quot;Type program names and arguments, and hit enter.\n&quot;);
  printf(&quot;The following are built in:\n&quot;);

  for (i = 0; i &lt; lsh_num_builtins(); i++) {
    printf(&quot;  %s\n&quot;, builtin_str[i]);
  }

  printf(&quot;Use the man command for information on other programs.\n&quot;);
  return 1;
}

int lsh_exit(char **args)
{
  return 0;
}
</code></pre>

<p>代码分为三个部分。第一部分包含函数的前置声明。前置声明使得你可以在定义它（而尚未实现时）以前使用它的名字。我这样做的原因是因为<code>lsh_help()</code>函数需要用到内置函数数组，而这个数组包含<code>lsh_help()</code>的函数名。解决这一依赖循环的最简洁办法就是使用前置声明了。</p>

<p>下一部分是一个包含内置命令名称的数组，及包含其相应函数的数组。这样实现的原因是，在未来，可以简单地通过修改此数组来添加内置命令，而不必通过编辑代码中某处一个大型的”switch“语句段。如果你对<code>builtin_func</code>的声明感到疑惑的话，没关系，我也如此！它是一个函数指针数组（接收字符串并返回一个<code>int</code>）。在C中，任何涉及到函数指针的声明都会引起困惑。我自己仍然在学习函数指针是如何声明的！</p>

<p>最后，我实现了每一个函数，<code>lsh_cd()</code>首先检查它接收的第二个参数是否存在，若否的话则打印错误信息。然后，它调用<code>chdir()</code>，检查是否有错误，返回。help函数打印帮助信息以及所有内置函数的名字。exit函数返回0，作为<code>loop</code>循环命令终止的信号。</p>

<h2 id="将内置函数和进程整合起来">将内置函数和进程整合起来</h2>

<p>最后一片迷失的拼图就是实现<code>lsh_execute()</code>函数了，它将会启动一个内置函数，或者一个进程。如果你已经读到了这儿的话，你会发现这个函数的实现是十分简单的：</p>

<pre><code class="language-c">int lsh_execute(char **args)
{
  int i;

  if (args[0] == NULL) {
    // An empty command was entered.
    return 1;
  }

  for (i = 0; i &lt; lsh_num_builtins(); i++) {
    if (strcmp(args[0], builtin_str[i]) == 0) {
      return (*builtin_func[i])(args);
    }
  }

  return lsh_launch(args);
}
</code></pre>

<p>它所做的全部事情就是，检查输入命令是否是内置命令，如果是的话，运行它。否则，调用<code>lsh_launch()</code>启动程序进程。值得考虑的一点是，如果用户输入了空字符串，或者空格符，输入参数<code>args</code>就有可能为NULL。所以，我们需要在开头就检查这些情况。</p>

<h2 id="组织代码">组织代码</h2>

<p>以上就是Shell中的全部代码了。如果你读到了这里，你应该已经完全明白Shell的工作原理了。为了尝试运行它（在一台Linux机器上），你应该将这些代码整合到一个文件中（<code>main.c</code>)，并且编译它。要注意其中只应包含一个<code>lsh_read_line()</code>函数的实现。你需要在文件顶部包含以下头文件。我添加了注释来帮助你了解每个函数的出处。</p>

<ul>
<li><pre><code>#include &lt;sys/wait.h&gt;
</code></pre>

<ul>
<li><code>waitpid()</code> and associated macros</li>
</ul></li>

<li><pre><code>#include &lt;unistd.h&gt;
</code></pre>

<ul>
<li><code>chdir()</code></li>
<li><code>fork()</code></li>
<li><code>exec()</code></li>
<li><code>pid_t</code></li>
</ul></li>

<li><pre><code>#include &lt;stdlib.h&gt;
</code></pre>

<ul>
<li><code>malloc()</code></li>
<li><code>realloc()</code></li>
<li><code>free()</code></li>
<li><code>exit()</code></li>
<li><code>execvp()</code></li>
<li><code>EXIT_SUCCESS</code>, <code>EXIT_FAILURE</code></li>
</ul></li>

<li><pre><code>#include &lt;stdio.h&gt;
</code></pre>

<ul>
<li><code>fprintf()</code></li>
<li><code>printf()</code></li>
<li><code>stderr</code></li>
<li><code>getchar()</code></li>
<li><code>perror()</code></li>
</ul></li>

<li><pre><code>#include &lt;string.h&gt;
</code></pre>

<ul>
<li><code>strcmp()</code></li>
<li><code>strtok()</code></li>
</ul></li>
</ul>

<p>一旦你已经编写好了代码和头文件，那么只需要运行<code>gcc -o main main.c</code>来编译它，然后使用<code>./main</code>来运行就好了。</p>

<p>或者，你也可以在<a href="https://github.com/brenns10/lsh/tree/407938170e8b40d231781576e05282a41634848c">Github</a>上找到这些代码。该链接直接指向编写本文时的当前修订版的代码——在未来的某一天我可能会考虑更新它并加上一些新功能。如果我这么做了，我会尽我所能地将这些细节和实现思路更新在文章中的。</p>

<h2 id="总结">总结</h2>

<p>如果你已经读到了这里，并且好奇我究竟是怎么知道如何使用这些系统调用函数的，答案十分简单：<code>man</code>手册。在<code>man 3p</code>里，每个系统调用都有详尽的文档。如果你清楚你的需求，并且想知道如果去实现它，<code>man</code>手册将是你的绝佳助手。如果你不清楚C标准库和Unix系统给你提供了哪些接口，我向你推荐<a href="http://pubs.opengroup.org/onlinepubs/9699919799/">POSIX  规范</a>，特别是<strong>13章节</strong>，”Headers“。你可以在那里找到每一个拥有详尽定义的头文件文档。</p>

<p>当然，这个Shell并不是功能完备的。明显的一些缺陷就包括：</p>

<ul>
<li>仅允许使用空格分隔参数，不允许使用引用或是反斜杠转义。</li>
<li>没有管道或重定向。</li>
<li>仅有少量的内置函数。</li>
<li>不支持通配符。</li>
</ul>

<p>上述功能的实现是十分有趣的事情，但那样已经远远超出我这篇文章所能容纳的内容范围了。如果我有机会去实现其中之一的话，我会写一篇后续文章的。但是我鼓励我的读者们去亲自实现这些功能。如果你成功了的话，请在评论区留言，我十分乐于见到这些代码。</p>

<p>最后，感谢阅读本篇教程（如果有人这么做了的话）。我享受写作本文的过程，希望你们能同样享受阅读它的过程。在评论区留下你们的想法吧！</p>

<p><strong>后记：</strong>在文章的早期版本中，我在<code>lsh_split_line()</code>中遇到了一些烦人的错误，这些错误恰好导致了函数间相互抵消。感谢Reddit上的<code>/u/munmap</code>（还有其他一些评论用户）找到了这些错误！可在<a href="https://github.com/brenns10/lsh/commit/486ec6dcdd1e11c6dc82f482acda49ed18be11b5">diff</a>中查看我犯了什么错误。</p>

<p><strong>后记2：</strong>感谢Github用户ghswa为函数<code>malloc()</code>所做出的null检查贡献。他/她同样指出了<code>get_line()</code>函数的<a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/getline.html">manpage</a>上表明其第一个参数应是可释放的，故而在我使用了<code>getline()</code>实现的<code>lsh_read_line()</code>函数中，<code>line</code>应被初始化为<code>NULL</code>。</p>

    
    <div class="creative-commons">
        <a rel="license"
           href="https://creativecommons.org/licenses/by-sa/4.0/"><img
           alt="知识共享许可协议" style="border-width:0"
           src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" />
        </a><br />
    </div>
    
	</div>
  <footer class="article-footer clearfix">
  

<div class="article-tags">
  <span></span>
  
  <a href="https://bivectorfoil.github.io/tags/shell">shell</a>
  
  <a href="https://bivectorfoil.github.io/tags/c">C</a>
  
</div>





<div class="article-categories">
  <span></span>
  
  <a class="article-category-link" href="https://bivectorfoil.github.io/categories/%E6%8A%80%E6%9C%AF%E7%BF%BB%E8%AF%91">技术翻译</a>
  
</div>



  <div class="article-share" id="share">
    <div data-url="https://bivectorfoil.github.io/post/write-a-shell-in-c/" data-title="[译］教程 - 用C实现一个Shell" data-tsina="" class="share clearfix">
    </div>
  </div>
</footer>

	</article>
  


<section class="comment">
<div id="disqus_thread"></div>
</section>
<script>
  <!-- detect whether Disuqs can load -->
  var xhr = new XMLHttpRequest();
  xhr.open('GET', '//disqus.com/next/config.json?' + new Date().getTime(), true);
  xhr.timeout = 3000; 

  xhr.onload = function() { 


var disqus_config = function () {
this.page.url = "https://bivectorfoil.github.io/post/write-a-shell-in-c/";
this.page.identifier = "https://bivectorfoil.github.io/post/write-a-shell-in-c/";
};
(function() { 
var d = document, s = d.createElement('script');

s.src = '//zvector.disqus.com/embed.js';

s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
}
  xhr.ontimeout = function() {
  <!-- cannot load Disqus, skip it. -->
  return;
}
xhr.send(null);
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


</div>

    <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>
<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">
  

<div class="categorieslist">
  <p class="asidetitle">分类</p>
  <ul>
    
    <li><a href="https://bivectorfoil.github.io/categories/%e6%8a%80%e6%9c%af%e5%a4%87%e5%bf%98%e5%bd%95" title="技术备忘录">技术备忘录<sup>11</sup></a></li>
    
    <li><a href="https://bivectorfoil.github.io/categories/%e6%8a%80%e6%9c%af%e7%bf%bb%e8%af%91" title="技术翻译">技术翻译<sup>1</sup></a></li>
    
    <li><a href="https://bivectorfoil.github.io/categories/%e6%8a%80%e6%9c%af%e9%97%b2%e8%b0%88" title="技术闲谈">技术闲谈<sup>3</sup></a></li>
    
    <li><a href="https://bivectorfoil.github.io/categories/%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0" title="读书笔记">读书笔记<sup>2</sup></a></li>
    
  </ul>
</div>



  

<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
      
			<li><a href="https://bivectorfoil.github.io/tags/blog" title="blog">blog<sup>2</sup></a></li>
      
			<li><a href="https://bivectorfoil.github.io/tags/c" title="c">c<sup>1</sup></a></li>
      
			<li><a href="https://bivectorfoil.github.io/tags/docker" title="docker">docker<sup>1</sup></a></li>
      
			<li><a href="https://bivectorfoil.github.io/tags/domain-name" title="domain-name">domain-name<sup>1</sup></a></li>
      
			<li><a href="https://bivectorfoil.github.io/tags/gunicorn" title="gunicorn">gunicorn<sup>1</sup></a></li>
      
			<li><a href="https://bivectorfoil.github.io/tags/http" title="http">http<sup>2</sup></a></li>
      
			<li><a href="https://bivectorfoil.github.io/tags/hugo" title="hugo">hugo<sup>2</sup></a></li>
      
			<li><a href="https://bivectorfoil.github.io/tags/lets-encrypt" title="lets-encrypt">lets-encrypt<sup>1</sup></a></li>
      
			<li><a href="https://bivectorfoil.github.io/tags/linux" title="linux">linux<sup>1</sup></a></li>
      
			<li><a href="https://bivectorfoil.github.io/tags/machine-learning" title="machine-learning">machine-learning<sup>1</sup></a></li>
      
			<li><a href="https://bivectorfoil.github.io/tags/memo" title="memo">memo<sup>5</sup></a></li>
      
			<li><a href="https://bivectorfoil.github.io/tags/mysql" title="mysql">mysql<sup>1</sup></a></li>
      
			<li><a href="https://bivectorfoil.github.io/tags/nginx" title="nginx">nginx<sup>2</sup></a></li>
      
			<li><a href="https://bivectorfoil.github.io/tags/notes" title="notes">notes<sup>3</sup></a></li>
      
			<li><a href="https://bivectorfoil.github.io/tags/python" title="python">python<sup>1</sup></a></li>
      
			<li><a href="https://bivectorfoil.github.io/tags/script" title="script">script<sup>1</sup></a></li>
      
			<li><a href="https://bivectorfoil.github.io/tags/shell" title="shell">shell<sup>2</sup></a></li>
      
			<li><a href="https://bivectorfoil.github.io/tags/ssserver" title="ssserver">ssserver<sup>1</sup></a></li>
      
			<li><a href="https://bivectorfoil.github.io/tags/tech" title="tech">tech<sup>1</sup></a></li>
      
			<li><a href="https://bivectorfoil.github.io/tags/tmux" title="tmux">tmux<sup>1</sup></a></li>
      
			<li><a href="https://bivectorfoil.github.io/tags/ubuntu16.04" title="ubuntu16.04">ubuntu16.04<sup>1</sup></a></li>
      
			<li><a href="https://bivectorfoil.github.io/tags/vim" title="vim">vim<sup>1</sup></a></li>
      
			<li><a href="https://bivectorfoil.github.io/tags/vps" title="vps">vps<sup>1</sup></a></li>
      
			<li><a href="https://bivectorfoil.github.io/tags/web" title="web">web<sup>1</sup></a></li>
      
		</ul>
</div>



  
  <div class="archiveslist">
    <p class="asidetitle">归档</p>
    <ul class="archive-list">
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://bivectorfoil.github.io/post/#2018-12">2018年12月</a><span class="archive-list-count">1</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://bivectorfoil.github.io/post/#2018-11">2018年11月</a><span class="archive-list-count">1</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://bivectorfoil.github.io/post/#2018-10">2018年10月</a><span class="archive-list-count">1</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://bivectorfoil.github.io/post/#2018-06">2018年06月</a><span class="archive-list-count">1</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://bivectorfoil.github.io/post/#2018-04">2018年04月</a><span class="archive-list-count">1</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://bivectorfoil.github.io/post/#2018-03">2018年03月</a><span class="archive-list-count">3</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://bivectorfoil.github.io/post/#2017-12">2017年12月</a><span class="archive-list-count">6</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://bivectorfoil.github.io/post/#2017-11">2017年11月</a><span class="archive-list-count">3</span>
      </li>
      
    </ul>

  </div>


  

<div class="tagcloudlist">
  <p class="asidetitle">标签云</p>
  <div class="tagcloudlist clearfix">
    
    <a href="https://bivectorfoil.github.io/tags/blog" style="font-size: 12px;">blog</a>
    
    <a href="https://bivectorfoil.github.io/tags/c" style="font-size: 12px;">c</a>
    
    <a href="https://bivectorfoil.github.io/tags/docker" style="font-size: 12px;">docker</a>
    
    <a href="https://bivectorfoil.github.io/tags/domain-name" style="font-size: 12px;">domain-name</a>
    
    <a href="https://bivectorfoil.github.io/tags/gunicorn" style="font-size: 12px;">gunicorn</a>
    
    <a href="https://bivectorfoil.github.io/tags/http" style="font-size: 12px;">http</a>
    
    <a href="https://bivectorfoil.github.io/tags/hugo" style="font-size: 12px;">hugo</a>
    
    <a href="https://bivectorfoil.github.io/tags/lets-encrypt" style="font-size: 12px;">lets-encrypt</a>
    
    <a href="https://bivectorfoil.github.io/tags/linux" style="font-size: 12px;">linux</a>
    
    <a href="https://bivectorfoil.github.io/tags/machine-learning" style="font-size: 12px;">machine-learning</a>
    
    <a href="https://bivectorfoil.github.io/tags/memo" style="font-size: 12px;">memo</a>
    
    <a href="https://bivectorfoil.github.io/tags/mysql" style="font-size: 12px;">mysql</a>
    
    <a href="https://bivectorfoil.github.io/tags/nginx" style="font-size: 12px;">nginx</a>
    
    <a href="https://bivectorfoil.github.io/tags/notes" style="font-size: 12px;">notes</a>
    
    <a href="https://bivectorfoil.github.io/tags/python" style="font-size: 12px;">python</a>
    
    <a href="https://bivectorfoil.github.io/tags/script" style="font-size: 12px;">script</a>
    
    <a href="https://bivectorfoil.github.io/tags/shell" style="font-size: 12px;">shell</a>
    
    <a href="https://bivectorfoil.github.io/tags/ssserver" style="font-size: 12px;">ssserver</a>
    
    <a href="https://bivectorfoil.github.io/tags/tech" style="font-size: 12px;">tech</a>
    
    <a href="https://bivectorfoil.github.io/tags/tmux" style="font-size: 12px;">tmux</a>
    
    <a href="https://bivectorfoil.github.io/tags/ubuntu16.04" style="font-size: 12px;">ubuntu16.04</a>
    
    <a href="https://bivectorfoil.github.io/tags/vim" style="font-size: 12px;">vim</a>
    
    <a href="https://bivectorfoil.github.io/tags/vps" style="font-size: 12px;">vps</a>
    
    <a href="https://bivectorfoil.github.io/tags/web" style="font-size: 12px;">web</a>
    
  </div>
</div>



  

</aside>
</div>

  </div>
  <footer><div id="footer" >
  
  <div class="line">
    <span></span>
    <div style='background:no-repeat url("https://bivectorfoil.github.io/img/author.jpg") left top;-webkit-background-size:6.875em 6.875em;-moz-background-size:6.875em 6.875em;background-size:6.875em 6.875em;' class="author" ></div>
  </div>
  
  
  <section class="info">
    <p>Connect the world <br/> Learn the world</p>
  </section>
  
  <div class="social-font clearfix">
    
    
    
    <a href="https://github.com/Bivectorfoil" target="_blank" title="github"></a>
    
    
    
  </div>
  <p class="copyright">Powered by <a href="http://gohugo.io" target="_blank" title="hugo">hugo</a> and Theme by <a href="https://github.com/coderzh/hugo-pacman-theme" target="_blank" title="hugo-pacman-theme">hugo-pacman-theme</a> © 2018
    
    <a href="https://bivectorfoil.github.io/" target="_blank" title="zvector">zvector</a>
    
  </p>
</div>
</footer>
  <script src="https://bivectorfoil.github.io/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
done = false;
$(document).ready(function(){
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize();
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  $('form.search').on('submit', function (event) {
    if (false === done) {
      event.preventDefault();
      var orgVal = $(this).find('#search').val();
      $(this).find('#search').val('site:https:\/\/bivectorfoil.github.io\/ ' + orgVal);
      done = true;
      $(this).submit();
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>

<script type="text/javascript">
$(document).ready(function(){
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});
</script>


<link rel="stylesheet" href="https://bivectorfoil.github.io/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="https://bivectorfoil.github.io/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
});
</script>




</body>
</html>
